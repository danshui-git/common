name: 'Clean Old Workflow Runs'
description: 'Deletes old GitHub Actions runs keeping specified number of recent ones'

branding:
  icon: "trash"
  color: "gray-dark"

inputs:
  runs_to_keep:
    description: "Number of latest runs to keep (index starts at 0)"
    required: true
    type: number
    default: 20
  fetch_limit:
    description: "Maximum number of runs to fetch"
    required: true
    type: number
    default: 500
  github_token:
    description: "GitHub token for authentication"
    required: true
    default: "${{ github.token }}"

runs:
  using: "composite"
  steps:
    - name: "Set up environment"
      shell: bash
      run: |
        RUNS_TO_KEEP="${{ inputs.runs_to_keep }}"
        echo "RUNS_TO_KEEP=${RUNS_TO_KEEP}" >> $GITHUB_ENV
        FETCH_LIMIT="${{ inputs.fetch_limit }}"
        echo "FETCH_LIMIT=${FETCH_LIMIT}" >> $GITHUB_ENV
        echo "环境变量设置完成：保留 $RUNS_TO_KEEP 条记录，最多拉取 $FETCH_LIMIT 条"

    - name: "Authenticate GitHub CLI"
      shell: bash
      run: |
        echo "${{ inputs.github_token }}" | gh auth login --with-token
        echo "认证成功！当前 GitHub CLI 版本：$(gh --version)"

    - name: "Fetch workflow runs"
      shell: bash
      id: fetch_runs
      run: |
        # 使用 --paginate 参数确保获取所有页面的记录
        RUNS_JSON=$(gh run list --status completed --status failure --status success --status cancelled --limit "$FETCH_LIMIT" --paginate --json databaseId,createdAt)
        
        if [ -z "$RUNS_JSON" ]; then
          echo "未找到工作流运行记录，无需删除"
          exit 0
        fi
        
        RUN_COUNT=$(echo "$RUNS_JSON" | jq length)
        echo "RUN_COUNT=$RUN_COUNT" >> $GITHUB_ENV
        echo "成功获取 $RUN_COUNT 条工作流运行记录"
        
        if [ "$RUN_COUNT" -le "$RUNS_TO_KEEP" ]; then
          echo "现有记录数（$RUN_COUNT）≤ 保留数（$RUNS_TO_KEEP），无需删除"
          exit 0
        fi
        
        echo "runs_to_delete=true" >> $GITHUB_OUTPUT
        echo "需要删除旧记录：$((RUN_COUNT - RUNS_TO_KEEP)) 条"

    - name: "Delete old runs"
      shell: bash
      if: steps.fetch_runs.outputs.runs_to_delete == 'true'
      run: |
        # 重新获取完整的 RUNS_JSON（避免跨步骤变量作用域问题）
        RUNS_JSON=$(gh run list --status completed --status failure --status success --status cancelled --limit "$FETCH_LIMIT" --paginate --json databaseId,createdAt)
        RUN_COUNT=$(echo "$RUNS_JSON" | jq length)
        
        echo -e "\n===== 开始删除旧记录 ====="
        echo "保留前 $RUNS_TO_KEEP 条最新记录，删除剩余 $((RUN_COUNT - RUNS_TO_KEEP)) 条"
        
        # 提取待删除的运行ID
        RUNS_TO_DELETE=$(echo "$RUNS_JSON" | jq --argjson keep "$RUNS_TO_KEEP" -r '.[$keep:][].databaseId')
        
        if [ -z "$RUNS_TO_DELETE" ]; then
          echo "未找到需要删除的记录"
          exit 0
        fi
        
        # 输出待删除的ID列表（最多显示前5个）
        echo "待删除的记录ID（共 $(echo "$RUNS_TO_DELETE" | wc -w) 条）:"
        echo "$RUNS_TO_DELETE" | head -n 5 | sed 's/^/ - /'
        [ $(echo "$RUNS_TO_DELETE" | wc -w) -gt 5 ] && echo "  ...（剩余 $(($(echo "$RUNS_TO_DELETE" | wc -w) - 5)) 条）"
        
        # 执行删除操作（使用 -y 参数自动确认）
        DELETE_SUCCESS=0
        DELETE_FAILED=0
        
        echo "$RUNS_TO_DELETE" | while read -r RUN_ID; do
          echo "正在删除 ID: $RUN_ID"
          if gh run delete "$RUN_ID" -y; then
            DELETE_SUCCESS=$((DELETE_SUCCESS + 1))
            sleep 0.5  # 避免触发API速率限制
          else
            echo "❌ 删除失败：$RUN_ID" >&2
            DELETE_FAILED=$((DELETE_FAILED + 1))
          fi
        done
        
        echo -e "\n===== 删除结果 ====="
        echo "成功删除: $DELETE_SUCCESS"
        echo "删除失败: $DELETE_FAILED"
        
        if [ "$DELETE_FAILED" -gt 0 ]; then
          echo "警告：有 $DELETE_FAILED 个运行记录删除失败" >&2
          exit 1  # 可选：根据需要决定是否让Action整体失败
        else
          echo "✅ 所有旧记录已成功删除"
        fi
